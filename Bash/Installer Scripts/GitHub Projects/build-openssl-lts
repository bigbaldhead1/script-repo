#!/usr/bin/env bash
# shellcheck disable=SC2068,SC2086,SC2162,SC2317

# Purpose: Build the latest stable release of OpenSSL from the official website's source code
# Enabled features: fips, rc5, shared, tfo, threads, zlib
# Version: 2.1

# Check for root/and exit if detected
if [ "$EUID" -ne 0 ]; then
    printf "%s\n\n" "You must run this script with root/sudo."
    exit 1
fi

# Function to print a message and exit
exit_fn() {
    printf "\n%s\n\n%s\n\n" \
        "Make sure to star this repository to show your support!" \
        "https://github.com/slyfox1186/script-repo"
    exit 0
}

# Function to print an error message and exit
fail_fn() {
    printf "\n\n%s\n\n%s\n\n%s\n\n" \
        "$1" \
        "To report a bug please create an issue at:" \
        "https://github.com/slyfox1186/script-repo/issues"
    exit 1
}

# Function to prompt user for cleanup
cleanup_fn() {
    local choice

    printf "\n%s\n%s\n%s\n\n%s\n%s\n\n" \
        "============================================" \
        "  Do you want to clean up the build files?  " \
        "============================================" \
        "[1] Yes" \
        "[2] No"
    read -p "Your choices are (1 or 2): " choice

    case "$choice" in
        1)  rm -fr "$cwd" ;;
        2)  echo ;;
        *)
            unset choice
            clear
            cleanup_fn
            ;;
    esac
}

# Function to display the OpenSSL version
show_ver_fn() {
    clear
    show_ver="$(/usr/local/ssl/bin/openssl version -a | grep -Eo "[0-9\.]?+" | head -n1)"
    printf "%s\n" "The updated OpenSSL version is: $show_ver"
}

# Function to install required packages on Arch Linux
pkgs_arch_fn() {
    local missing_pkgs

    pkgs=(
        autoconf autogen automake base-devel ca-certificates ccache clang curl
        c-ares libcurl-gnutls gperftools mimalloc libgcrypt gmp libgpg-error
        jemalloc mbedtls libssh libssh2 libtool libxml2 lksctp-tools m4 zlib-ng
    )

    for pkg in "${pkgs[@]}"
    do
        if ! pacman -Qs "$pkg" >/dev/null; then
            missing_pkgs+=("$pkg ")
        fi
    done

    if [ -n "$missing_pkgs" ]; then
        pacman -S --needed --noconfirm ${missing_pkgs[@]}
        clear
    fi
}

# Function to install required packages on Debian/Ubuntu
pkgs_fn() {
    local missing_packages available_packages unavailable_packages

    pkgs=(
        autoconf autogen automake build-essential ca-certificates ccache
        checkinstall clang curl libc-ares-dev libcurl4-openssl-dev
        libdmalloc-dev libgcrypt20-dev libgmp-dev libgpg-error-dev
        libjemalloc-dev libmbedtls-dev libsctp-dev libssh2-1-dev
        libssh-dev libssl-dev libtool libtool-bin libxml2-dev m4 perl
        zlib1g-dev
    )

    # Initialize arrays for missing, available, and unavailable packages
    missing_packages=()
    available_packages=()
    unavailable_packages=()

    # Loop through the array to find missing packages
    for pkg in "${pkgs[@]}"
    do
        if ! dpkg-query -W -f='${Status}' "$pkg" 2>/dev/null | grep -q "ok installed"; then
            missing_packages+=("$pkg")
        fi
    done

    # Check availability of missing packages and categorize them
    for pkg in "${missing_packages[@]}"
    do
        if apt-cache show "$pkg" > /dev/null 2>&1; then
            available_packages+=("$pkg")
        else
            unavailable_packages+=("$pkg")
        fi
    done

    # Print unavailable packages
    if [[ "${#unavailable_packages[@]}" -gt 0 ]]; then
        echo "Unavailable packages: ${unavailable_packages[*]}"
    fi

    # Install available missing packages
    if [[ "${#available_packages[@]}" -gt 0 ]]; then
        echo "Installing available missing packages: ${available_packages[*]}"
        apt install "${available_packages[@]}"
    else
        printf "%s\n\n" "No missing packages to install or all missing packages are unavailable."
    fi
}

# Function to check and create directories
create_dir() {
    local dir="$1"
    if [ ! -d "$dir" ]; then
        mkdir -p "$dir"
    fi
}

# Function to download a file
download_file() {
    local url="$1"
    local output_file="$2"
    if [ ! -f "$output_file" ]; then
        wget -cqO "$output_file" "$url"
    fi
}

# Function to extract an archive
extract_archive() {
    local archive_file="$1"
    local target_dir="$2"
    if ! tar -zxf "$archive_file" -C "$target_dir" --strip-components 1; then
        printf "%s\n\n" "Failed to extract: $archive_file"
        exit 1
    fi
}

add_to_path() {
    [[ -f "/usr/local/bin/openssl" ]] && rm "/usr/local/bin/openssl"
    ln -sf "/usr/local/ssl/bin/openssl" "/usr/local/bin"
}

# Function to configure and build OpenSSL
build_openssl() {
    cd "$1" || exit 1
    ../Configure linux-x86_64-clang \
                 -DOPENSSL_USE_IPV6=0 \
                 -Wl,-rpath="$install_dir/lib64" \
                 -Wl,--enable-new-dtags \
                 --prefix="$install_dir" \
                 --openssldir="$ssl_dir" \
                 --release \
                 --with-zlib-include="/usr/include" \
                 --with-zlib-lib="/usr/lib/x86_64-linux-gnu" \
                 enable-ec_nistp_64_gcc_128 \
                 enable-egd \
                 enable-fips \
                 enable-rc5 \
                 enable-sctp \
                 enable-shared \
                 enable-threads \
                 enable-zlib \
                 no-tests

    echo
    if ! make "-j$(nproc --all)"; then
        fail_fn "Failed to execute: make -j$(nproc --all). Line: $LINENO"
    fi

    echo
    if ! make install_sw install_fips; then
        fail_fn "Failed to execute: make install_sw install_fips. Line: $LINENO"
    else
        openssl fipsinstall
    fi
}

# Function to install CA certificates from cURL's website
install_ca_certs() {
    printf "\n%s\n%s\n\n" \
        "Install the latest security certificate from cURL's website" \
        "==================================================================="
    sleep 2

    create_dir "$cert_dir"

    download_file "https://curl.se/ca/cacert.pem" "$cwd/cacert.pem"

    if ! mv "$cwd/cacert.pem" "$cert_dir/cacert.pem"; then
        fail_fn "Failed to move file: $cwd/cacert.pem >> $cert_dir/cacert.pem. Line: $LINENO"
    else
        cp "$cert_dir/cacert.pem" "/usr/local/share/ca-certificates/curl-cacert.crt"
    fi

    cp -fr /etc/ssl/certs/* "$cert_dir"

    cd "$cert_dir" || exit 1
    c_rehash .
    update-ca-certificates
}

# Function to update the linker library search path
update_ldconfig() {
    echo "$install_dir/lib64" | tee "/etc/ld.so.conf.d/openssl-compiled.conf" >/dev/null
    ldconfig "/usr/local/ssl/lib64"
}

# Set script variables
script_ver="2.1"
openssl_ver="$(curl -s https://www.openssl.org/source/ | grep -o "openssl-3.1\.[4-9]\{1,2\}" | head -n 1)"
archive_url="https://www.openssl.org/source/$openssl_ver.tar.gz"
archive_ext="${archive_url//*./}"
archive_name="$openssl_ver.tar.$archive_ext"
cwd="$PWD/openssl-build-script"
install_dir="/usr/local/ssl"
ssl_dir="$install_dir"
cert_dir="$install_dir/certs"

# Print header
printf "%s\n%s\n\n" \
    "OpenSSL LTS Build Script - v$script_ver" \
    "==============================================="
sleep 2

# Create output directory
create_dir "$cwd"

# Detect OS and version
find_lsb_release="$(find /usr/bin/ -type f -name "lsb_release")"

if [ -f "/etc/os-release" ]; then
    . "/etc/os-release"
    OS_TMP="$NAME"
    OS="$(echo "$OS_TMP" | awk "{print $1}")"
elif [ -n "$find_lsb_release" ]; then
    OS="$(lsb_release -d | awk "{print $2}")"
else
    fail_fn "Failed to define the \$OS and/or \$VER variables. Line: $LINENO"
fi

# If Ubuntu is the current OS, softlink for OpenSSL to function
ubuntu_os_ver() {
    ln -sf "/usr/lib64/libcrypto.so.3" "/usr/lib64/libcrypto.so"
}

case "$OS" in
    Ubuntu) ubuntu_os_ver ;;
esac

# Install required packages based on OS
if [[ "$OS" == "Arch" ]]; then
    pkgs_arch_fn
else
    pkgs_fn
fi

# Download the archive file
download_file "$archive_url" "$cwd/$archive_name"

# Create output directory for extraction
create_dir "$cwd/$openssl_ver/build"

# Extract archive files
extract_archive "$cwd/$archive_name" "$cwd/$openssl_ver"

# Build OpenSSL from source
build_openssl "$cwd/$openssl_ver/build"

# Install CA certificates from cURL's website
install_ca_certs

# Update linker library search path
update_ldconfig

# Add OpenSSL bin to user's ~/.bashrc file
add_to_path

# Prompt user to clean up files
cleanup_fn

# Display updated OpenSSL version
show_ver_fn

# Exit with message
exit_fn
