#!/usr/bin/env bash
# shellcheck disable=SC2162,SC2317

##  GitHub: https://github.com/slyfox1186/script-repo/blob/main/Bash/Installer%20Scripts/GitHub%20Projects/build-tools
##  Purpose: Install the latest versions of: CMake, Ninja, Meson, & Golang
##  Updated: 01.14.24

clear

if [ "$EUID" -eq 0 ]; then
    printf "%s\n\n" "You must run this script WITHOUT root/sudo"
    exit 1
fi

# CREATE SCRIPT VARIABLES
script_ver="2.8"
cwd="$PWD/build-tools-script"
install_dir="/usr/local"
user_agent="Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/121.0.0.0 Safari/537.36"
web_repo="https://github.com/slyfox1186/script-repo"
latest=false
debug=OFF # CHANGE THE DEBUG VARIABLE TO "ON" FOR HELP TROUBLESHOOTING ISSUES

# PRINT SCRIPT BANNER
printf "%s\n%s\n" "Build-tools script: v$script_ver" "===================================="
sleep 2

# GET CPU CORE COUNT FOR PARALLEL PROCESSING
cpu_threads=$(grep --count ^processor '/proc/cpuinfo' 2>/dev/null || nproc --all)

# CREATE OUTPUT DIRECTORIES
mkdir -p "$cwd"

# SET THE CC/CXX COMPILERS & THE COMPILER OPTIMIZATION FLAGS
CC=gcc
CXX=g++
CFLAGS="-g -O3 -pipe -march=native"
CXXFLAGS="$CFLAGS"
CPPFLAGS="-I/usr/local/include -I/usr/include"
LDFLAGS+="-L/usr/local/lib64 -L/usr/local/lib -L/usr/lib/x86_64-linux-gnu -L/usr/lib64 -L/usr/lib -L/lib64 -L/lib"
export CC CXX CFLAGS CPPFLAGS CXXFLAGS LDFLAGS

# SET THE PATH VARIABLE
PATH="\
/usr/lib/ccache:\
$HOME/perl5/bin:\
$HOME/.cargo/bin:\
$HOME/.local/bin:\
/usr/local/sbin:\
/usr/local/cuda/bin:\
/usr/local/x86_64-linux-gnu/bin:\
/usr/local/bin:\
/usr/sbin:\
/usr/bin:\
/sbin:\
/bin\
"
export PATH

# SET THE PKG_CONFIG_PATH VARIABLE
PKG_CONFIG_PATH="\
/usr/local/lib64/pkgconfig:\
/usr/local/lib/pkgconfig:\
/usr/local/lib/usr/local/pkgconfig:\
/usr/local/share/pkgconfig:\
/usr/lib64/pkgconfig:\
/usr/lib/pkgconfig:\
/usr/lib/$install_dir/pkgconfig:\
/usr/share/pkgconfig:\
/lib64/pkgconfig:\
/lib/pkgconfig:\
/lib/usr/local/pkgconfig\
"
export PKG_CONFIG_PATH

# CREATE FUNCTIONS
exit_fn() {
    printf "\n%s\n\n%s\n%s\n\n" "The script has completed" "Make sure to star this repository to show your support!" "$web_repo"
    exit 0
}

fail_fn() {
    printf "\n\n%s\n\n%s\n\n%s\n\n" "$1" "To report a bug please create an issue at:" "$web_repo/issues"
    exit 1
}

cleanup_fn() {
    local choice
    printf "\n%s\n\n%s\n%s\n\n" "Do you want to remove the build files?" "[1] Yes" "[2] No"
    read -p "Your choices are (1 or 2): " choice

    case "$choice" in
        1) sudo rm -fr "$cwd" ;;
        2) return 0 ;;
        *)
           unset choice
           clear
           cleanup_fn
           ;;
    esac
}

show_versions_fn() {
    local show_cmake_ver show_ninja_ver show_meson_ver show_go_ver
    clear

    show_cmake_ver=$(cmake --version | sed -e 's/cmake version //g' -e 's/CMake suite maintained and supported by Kitware (kitware.com\/cmake).//g' | xargs -n1)
    show_ninja_ver=$(ninja --version)
    show_meson_ver=$(meson --version)
    show_go_ver=$(go version | grep -Eo '[0-9\.]+ | xargs -n1')

    printf "%s\n\n%s\n%s\n%s\n%s\n" "The updated versions are:" "CMake:  $show_cmake_ver" "Ninja:  $show_ninja_ver" "Meson:  $show_meson_ver" "GoLang: $show_go_ver"
}

execute() {
    echo "$ $*"

    if [ "$debug" = "ON" ]; then
        if ! output="$("$@")"; then
            notify-send -t 5000 "Failed to execute: $*" 2>/dev/null
            fail_fn "Failed to execute: $*"
        fi
    else
        if ! output="$("$@" 2>&1)"; then
            notify-send -t 5000 "Failed to execute: $*" 2>/dev/null
            fail_fn "Failed to execute: $*"
        fi
    fi
}

download() {
    dl_path="$cwd"
    dl_url="$1"
    dl_file="${2:-"${1##*/}"}"

    if [[ "$dl_file" =~ tar. ]]; then
        output_dir="${dl_file%.*}"
        output_dir="${3:-"${output_dir%.*}"}"
    else
        output_dir="${3:-"${dl_file%.*}"}"
    fi

    target_file="$dl_path/$dl_file"
    target_dir="$dl_path/$output_dir"

    if [ -f "$target_file" ]; then
        echo "The file \"$dl_file\" is already downloaded."
    else
        echo "Downloading \"$dl_url\" saving as \"$dl_file\""
        if ! curl -A "$user_agent" -Lso "$target_file" "$dl_url"; then
            printf "\n%s\n\n" "The script failed to download \"$dl_file\" and will try again in 10 seconds..."
            sleep 10
            if ! curl -A "$user_agent" -Lso "$target_file" "$dl_url"; then
                fail_fn "The script failed to download \"$dl_file\" twice and will now exit:Line $LINENO"
            fi
        fi
        echo "Download Completed"
    fi

    if [ -d "$target_dir" ]; then
        sudo rm -fr "$target_dir"
    fi
    mkdir -p "$target_dir"

    if [ -n "$3" ]; then
        if ! tar -xf "$target_file" -C "$target_dir" 2>/dev/null >/dev/null; then
            sudo rm "$target_file"
            fail_fn "The script failed to extract \"$dl_file\" so it was deleted. Please re-run the script. Line: $LINENO"
        fi
    else
        if ! tar -xf "$target_file" -C "$target_dir" --strip-components 1 2>/dev/null >/dev/null; then
            sudo rm "$target_file"
            fail_fn "The script failed to extract \"$dl_file\" so it was deleted. Please re-run the script. Line: $LINENO"
        fi
    fi

    printf "%s\n\n" "File extracted: $dl_file"

    cd "$target_dir" || fail_fn "Unable to change the working directory to: $target_dir. Line: $LINENO"
}

download_git() {
    local dl_path dl_url dl_file target_dir

    dl_path="$cwd"
    dl_url="$1"
    dl_file="${2:-"${1##*/}"}"
    dl_file="${dl_file//\./-}"
    target_dir="$dl_path/$dl_file"

    if [ -n "$3" ]; then
        output_dir="$dl_path/$3"
        target_dir="$output_dir"
    fi

    if [ -d "$target_dir" ]; then
        sudo rm -fr "$target_dir"
    fi

    echo "Downloading $dl_url as $dl_file"

    if ! git clone -q "$dl_url" "$target_dir"; then
        printf "\n%s\n\n" "The script failed to clone the directory \"$target_dir\" and will try again in 10 seconds..."
        sleep 10
        if ! git clone -q "$dl_url" "$target_dir"; then
            fail_fn "The script failed to clone the directory \"$target_dir\" twice and will now exit the build. Line: $LINENO"
        fi
    else
        printf "%s\n\n" "Successfully cloned: $target_dir"
    fi

    cd "$target_dir" || fail_fn "Unable to change the working directory to: $target_dir. Line: $LINENO"
}

build() {
    printf "\n%s\n%s\n" "Building $1 - version $2" "===================================="

    if [ -f "$cwd/$1.done" ]; then
        if grep -Fx "$2" "$cwd/$1.done" >/dev/null; then
            echo "$1 version $2 already built. Remove $cwd/$1.done lockfile to rebuild it."
            return 1
        elif "${latest}"; then
            echo "$1 is outdated and will be rebuilt using version $2"
            return 0
        else
            echo "$1 is outdated, but will not be rebuilt. Pass in --latest to rebuild it or remove $cwd/$1.done lockfile."
            return 1
        fi
    fi
    return 0
}

build_done() { echo "$2" > "$cwd/$1.done"; }

# INSTALL REQUIRED APT/PACMAN PACKAGES
pkgs_arch_fn() {
    pkgs_arch=(
        autoconf automake autogen bluez-qt5 base-devel ccache cmake curl
        git libnghttp2 libnghttp3 openssl python python-pip qt5-base
        qt6-base
    )

    # Remove any locks on pacman
    [ -f "/var/lib/pacman/db.lck" ] && sudo rm "/var/lib/pacman/db.lck"

    for i in ${pkgs_arch[@]}
    do
        missing_pkg="$(sudo pacman -Qi | grep -o "$i")"

        if [ -z "$missing_pkg" ]; then
            missing_pkgs+=" $i"
        fi
    done

    if [ -n "$missing_pkgs" ]; then
         sudo pacman -Sq --needed --noconfirm $missing_pkgs
    fi

    [ -n "$(sudo find /usr/lib/python3* -type f -name 'EXTERNALLY-MANAGED')" ] && sudo rm "$rm_pip_lock"

    # INSTALL PYTHON PIP PACKAGES
    pip install -q --user --no-input requests setuptools wheel
}

pkgs_fn() {
    pkgs=(
        autoconf autoconf-archive automake autogen build-essential ccache
        cmake curl git libssl-dev libtool libtool-bin m4 python3 python3-pip
        qtbase5-dev
    )

    # Initialize arrays for missing, available, and unavailable packages
    missing_packages=()
    available_packages=()
    unavailable_packages=()

    # Loop through the array to find missing packages
    for pkg in "${pkgs[@]}"
    do
        if ! dpkg-query -W -f='${Status}' "$pkg" 2>/dev/null | grep -q "ok installed"; then
            missing_packages+=("$pkg")
        fi
    done

    # Check availability of missing packages and categorize them
    for pkg in "${missing_packages[@]}"
    do
        if apt-cache show "$pkg" > /dev/null 2>&1; then
            available_packages+=("$pkg")
        else
            unavailable_packages+=("$pkg")
        fi
    done

    # Print unavailable packages
    if [ "${#unavailable_packages[@]}" -gt 0 ]; then
        echo "Unavailable packages: ${unavailable_packages[*]}"
    fi

    # Install available missing packages
    if [ "${#available_packages[@]}" -gt 0 ]; then
        echo "Installing available missing packages: ${available_packages[*]}"
        sudo apt install "${available_packages[@]}"
    else
        printf "%s\n\n" "No missing packages to install or all missing packages are unavailable."
    fi
}

git_1_fn() {
    # Initial cnt
    local cnt curl_cmd git_repo
    git_repo="$1"
    cnt=1

    # Loop until the condition is met or a maximum limit is reached
    while [ $cnt -le 10 ]
    do
        curl_cmd="$(curl -sSL "https://github.com/$git_repo/tags")"

        # Extract the specific line
        line=$(echo "$curl_cmd" | grep -o 'href="[^"]*\.tar\.gz"' | sed -n "${cnt}p")

        # Check if the line matches the pattern (version without 'RC'/'rc')
        if echo "$line" | grep -qP '[v]*(\d+\.\d+(?:\.\d*){0,2})\.tar\.gz'; then
            # Extract and print the version number
            g_ver=$(echo "$line" | grep -oP '(\d+\.\d+(?:\.\d+){0,2})')
            break
        else
            # Increment the cnt if no match is found
            ((cnt++))
        fi
    done

    # Check if a version was found
    if [ $cnt -gt 10 ]; then
        echo "No matching version found without RC/rc suffix."
    fi
}

# Function to extract the first word from a string
get_first_word() { echo "$1" | awk '{print $1}'; }

# Try to detect the OS using /etc/os-release, fall back to lsb_release if available
if [ -f "/etc/os-release" ]; then
    . "/etc/os-release"
    OS=$(get_first_word "$NAME")
elif lsb_release -d &> /dev/null; then
    OS=$(lsb_release -d | awk '{print $2}')
else
    fail_fn "Failed to define the \$OS and/or \$VER variables. Line: $LINENO"
fi

case "$OS" in
    Arch)   pkgs_arch_fn ;;
    *)      pkgs_fn ;;
esac

# CHECK IF THE LATEST RELEASE IS A "RC" AKA RELEASE CANDIDATE AND IF SO GO BACK TO THE PREVIOUS STABLE RELEASE
git_1_fn "Kitware/CMake"
if build "cmake" "$g_ver"; then
    download "https://github.com/Kitware/CMake/archive/refs/tags/v$g_ver.tar.gz" "cmake-$g_ver.tar.gz"
    execute ./bootstrap --prefix="$install_dir" \
                        --enable-ccache \
                        --parallel="$(nproc --all)" \
                        --qt-gui
    execute make "-j$cpu_threads"
    execute sudo make install
    build_done "cmake" "$g_ver"
fi

git_1_fn "ninja-build/ninja"
if build "ninja" "$g_ver"; then
    download "https://github.com/ninja-build/ninja/archive/refs/tags/v$g_ver.tar.gz" "ninja-$g_ver.tar.gz"
    re2c_path="$(type -P re2c)"
    execute cmake -B build \
                  -DCMAKE_INSTALL_PREFIX="$install_dir" \
                  -DCMAKE_BUILD_TYPE=Release \
                  -DRE2C="$re2c_path" \
                  -DBUILD_TESTING=OFF \
                  -Wno-dev
    execute make "-j$cpu_threads" -C build
    execute sudo make -C build install
    build_done "ninja" "$g_ver"
fi

if [[ "${OS}" == "Arch" ]]; then
    sudo pacman -Sq --needed --noconfirm meson 2>&1
else
    git_1_fn "mesonbuild/meson"
    if build "meson" "$g_ver"; then
        download "https://github.com/mesonbuild/meson/archive/refs/tags/$g_ver.tar.gz" "meson-$g_ver.tar.gz"
        execute python3 setup.py build
        execute sudo python3 setup.py install --prefix="$install_dir"
        build_done "meson" "$g_ver"
    fi
fi

if [[ "$OS" == "Arch" ]]; then
    sudo pacman -Sq --needed --noconfirm go
    mkdir -p  "$HOME/go"
    GOPATH="$HOME/go"
    export GOPATH
    source "$HOME/.bash_profile"
else
    if build "golang" "1.21.6"; then
        download "https://go.dev/dl/go1.21.6.linux-amd64.tar.gz" "golang-1.21.6.tar.gz"
        execute sudo cp -f "bin/go" "bin/gofmt" "$install_dir/bin"
        if [ -d  "$install_dir/go" ]; then
            sudo rm -fr "$install_dir/go"
        fi
        sudo mkdir -p "$install_dir/go"
        GOROOT="$install_dir/go"
        PATH="$PATH:$GOROOT/bin"
        export GOROOT PATH
        build_done "golang" "1.21.6"
    fi
fi

# LDCONFIG MUST BE RUN NEXT IN ORDER TO UPDATE FILE CHANGES
sudo ldconfig 2>/dev/null

# SHOW THE NEWLY INSTALLED VERSION OF EACH PACKAGE
show_versions_fn

# PROMPT THE USER TO CLEAN UP THE BUILD FILES
cleanup_fn

# SHOW THE EXIT MESSAGE
exit_fn
